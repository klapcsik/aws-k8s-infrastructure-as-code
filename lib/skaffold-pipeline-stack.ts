import * as codebuild from '@aws-cdk/aws-codebuild';
import * as codecommit from '@aws-cdk/aws-codecommit';
import * as codepipeline from '@aws-cdk/aws-codepipeline';
import * as codepipeline_actions from '@aws-cdk/aws-codepipeline-actions';
import * as iam from '@aws-cdk/aws-iam';

import {NestedStack, NestedStackProps, Stack} from '@aws-cdk/core';


export interface SkaffoldImageBuildProps {
  /**
   * The prefix for the Docker image repository.
   * Example: "015589054601.dkr.ecr.eu-central-1.amazonaws.com/sparkasse/"
   */
  readonly repositoryPrefix: string,
  /**
   * The image name.
   * Example: "core-banking-service"
   */
  readonly name: string,
  /**
   * The tag for the image to be deployed.
   * Example: "v1"
   */
  readonly tag: string

  /**
   * Example: "015589054601.dkr.ecr.eu-central-1.amazonaws.com/sparkasse/core-banking-service:v1"
   */
//  readonly imageUri: string,
}

// [...] we define a new props interface for it, PipelineStackProps. This extends the 
// standard StackProps and is how clients of this class (including ourselves) pass 
// the Lambda code that the class needs.
export interface SkaffoldPipelineStackProps extends NestedStackProps {
  /**
   * Git repository name (e.g., 'sparkasse-web').
   */
  readonly repoName: string,
  /**
   * Branch name (if not present, branch 'master' will be assumed)
   */
  readonly branchName?: string,
  /**
   * If Git metata (.git directory) are to be present (e.g., Maven Git plugin may need them when including metadata within the final binary), this must be true. 
   * Otherwise no Git metadata will be available. 
   */
  readonly fetchGitMetadata?: boolean,

  /**
   * Skaffold profiles to be use when executing the skaffold command.
   */
  readonly skaffoldProfiles: string,

  /**
   * Kubernetes cluster name (e.g., 'sparkasse-dev')
   */
  readonly clusterName: string,

  /**
   * The administrator role ARN configured at EKS cluster creation.
   */
  readonly eksAdminRoleArn: string,

  /**
   * This Skaffold build will trigger an image build (default is false, meaning that no access to ECR is required)
   */
  readonly imageBuildProps?: SkaffoldImageBuildProps,
}

export class SkaffoldPipelineStack extends NestedStack {

  private _codeRepository: codecommit.IRepository;

  constructor(scope: Stack, id: string, props: SkaffoldPipelineStackProps) {
    super(scope, id, props);

    this._codeRepository = codecommit.Repository.fromRepositoryName(this, 'ImportedRepo',  props.repoName);

    // [...]builds the Lambda code. It begins by changing the current directory to lambda, which is where the Lambda code lives. 
    // It then installs any dependencies and the TypeScript compiler, then builds the code. The output is the contents of 
    // the node_modules directory, plus the index.js file. The Lambda runtime will call the `handler()` function in this 
    // file to handle requests.
    const skaffoldBuild = new codebuild.PipelineProject(this, 'SkaffoldBuild', {
      buildSpec: codebuild.BuildSpec.fromObject({
        version: '0.2',
        phases: {
          install: {
            commands: this.prepareInstallCommands( props ),
          },
          pre_build: {
            commands: this.preparePreBuildCommands( props )
          },
          build: {
            commands: this.prepareBuildCommands( props ),
          },
        },
        
      }),
      environment: {
        privileged: true, // Required for building Docker images
        buildImage: codebuild.LinuxBuildImage.STANDARD_4_0,
      },
    });

    this.addRequiredPermissionsToSkaffoldBuild( skaffoldBuild, props );

    // [...] we define our pipeline. It has a source Action targeting the CodeCommit repository, two build Actions using the previously 
    // defined projects, and finally a deploy Action that uses AWS CloudFormation. It takes the template generated by the AWS CDK 
    // build Project (stored in the LambdaStack.template.json file), passes it to AWS CloudFormation for deployment. 
    // To make the Lambda build output is an input to the AWS CloudFormation action, we pass it in the extraInputs property.
    const sourceOutput = new codepipeline.Artifact();
    const skaffoldBuildOutput = new codepipeline.Artifact('SkaffoldBuildOutput');

    const branchName = props.branchName ? props.branchName : 'master';

    new codepipeline.Pipeline(this, 'Pipeline', {
      stages: [
        {
          stageName: 'Source',
          actions: [
            new codepipeline_actions.CodeCommitSourceAction({
              actionName: 'CodeCommit_Source',
              repository: this._codeRepository,
              branch: branchName,
              output: sourceOutput,
            }),
          ],
        },
        {
          stageName: 'Build',
          actions: [
            new codepipeline_actions.CodeBuildAction({
              actionName: 'Skaffold_Build',
              project: skaffoldBuild,
              input: sourceOutput,
              outputs: [skaffoldBuildOutput],
            }),
          ],
        },
      ],
    });
  }

  protected prepareInstallCommands(props: SkaffoldPipelineStackProps): string[] {
    return [
      'BIN_DIR=$HOME/bin',
      'mkdir -p $BIN_DIR',

      // Git metadata script
      `curl -o $BIN_DIR/codebuild-git-wrapper.sh https://raw.githubusercontent.com/TimothyJones/codepipeline-git-metadata-example/master/scripts/codebuild-git-wrapper.sh`,

      // Kubernetes Tools
      'curl -o $BIN_DIR/aws-iam-authenticator https://amazon-eks.s3.us-west-2.amazonaws.com/1.17.9/2020-08-04/bin/linux/amd64/aws-iam-authenticator',
      'curl -o $BIN_DIR/skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64',
      'curl -o $BIN_DIR/kubectl https://storage.googleapis.com/kubernetes-release/release/v1.19.0/bin/linux/amd64/kubectl',
// Skaffold 1.15 should now use Kustomize as embedded within Kubectl      
      'curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash && mv kustomize $BIN_DIR',
      'chmod +x $BIN_DIR/*',
      'export PATH=$BIN_DIR:$PATH',

// Adjust maven settings, if the settings.xml is present      
      'if [ -f settings.xml ]; then cp ./settings.xml /root/.m2/settings.xml; fi',

      // Just for debugging purposes
      'aws --version' 
    ];
  }

  protected preparePreBuildCommands(props: SkaffoldPipelineStackProps): string[] {
    let commands: string[] = [];

    if (props.fetchGitMetadata) {
      const repositoryUrl = this._codeRepository.repositoryCloneUrlHttp;
      const branchName = props.branchName ? props.branchName : 'master';

      commands = commands.concat( [
        // See https://aws.amazon.com/blogs/devops/multi-branch-codepipeline-strategy-with-event-driven-architecture/
        `git config --global credential.helper '!aws codecommit credential-helper $@'`,
        `git config --global credential.UseHttpPath true`,
        `codebuild-git-wrapper.sh ${repositoryUrl} ${branchName}`
      ]);
    }

    commands = commands.concat( [
      '$(aws ecr get-login --no-include-email --region eu-central-1)',
  //      'aws sts get-caller-identity',
      `CREDENTIALS=$(aws sts assume-role --role-arn ${props.eksAdminRoleArn} --role-session-name codebuild-kubectl --duration-seconds 900)`,
  //    'echo $CREDENTIALS',
      'export AWS_ACCESS_KEY_ID="$(echo ${CREDENTIALS} | jq -r \'.Credentials.AccessKeyId\')"',
      'export AWS_SECRET_ACCESS_KEY="$(echo ${CREDENTIALS} | jq -r \'.Credentials.SecretAccessKey\')"',
      'export AWS_SESSION_TOKEN="$(echo ${CREDENTIALS} | jq -r \'.Credentials.SessionToken\')"',
      'export AWS_EXPIRATION=$(echo ${CREDENTIALS} | jq -r \'.Credentials.Expiration\')',
  //      'aws sts get-caller-identity',
  //      'aws eks list-clusters',
      `aws eks update-kubeconfig --name ${props.clusterName}`,
  //      'cat $KUBECONFIG',
    ] );

    return commands;
  }

  protected prepareBuildCommands(props: SkaffoldPipelineStackProps): string[] {
    let commands: string[] = [];
    
    // If we have to build or deploy a container as part of this Kubernetes deployment, then let's inform Skaffold about 
    // the container's image we want to deploy
    const imageProps = props.imageBuildProps;
    if (imageProps) {
      commands = [ 
        `skaffold run -p ${props.skaffoldProfiles} --tag=${imageProps.tag} --default-repo ${imageProps.repositoryPrefix}`
      ];
    } else {
      commands = [ 
        `skaffold run -p ${props.skaffoldProfiles}`
      ];
    }
    return commands;
  }

  protected addRequiredPermissionsToSkaffoldBuild( skaffoldBuild: codebuild.PipelineProject, props: SkaffoldPipelineStackProps ): void {
    const codebuildServiceRole = skaffoldBuild.role
    if (codebuildServiceRole) {
      // The skaffold build project will need permission to access and push images to ECR
      // See https://github.com/aws/aws-cdk/issues/1319 for more info (I've adapted it to new CDK API)
      const ecrPushPolicyStatement = new iam.PolicyStatement();
      ecrPushPolicyStatement.addActions( // From https://docs.aws.amazon.com/codebuild/latest/userguide/sample-docker.html
        'ecr:GetAuthorizationToken',
        'ecr:BatchCheckLayerAvailability',
        'ecr:CompleteLayerUpload',
        'ecr:InitiateLayerUpload',
        'ecr:PutImage',
        'ecr:BatchGetImage',
        'ecr:UploadLayerPart'
      );
      ecrPushPolicyStatement.addAllResources();

      skaffoldBuild.addToRolePolicy( ecrPushPolicyStatement );

      // Ensure that CodeBuild can assume the admin role over the EKS cluster
      const assumeRolePolicyStatement = new iam.PolicyStatement();
      assumeRolePolicyStatement.addActions('sts:AssumeRole');
      assumeRolePolicyStatement.addResources( props.eksAdminRoleArn );

      skaffoldBuild.addToRolePolicy( assumeRolePolicyStatement );

      // See https://itnext.io/how-to-access-git-metadata-in-codebuild-when-using-codepipeline-codecommit-ceacf2c5c1dc
      if (props.fetchGitMetadata) {
        const pullFromGitPolicyStatement = new iam.PolicyStatement();
        pullFromGitPolicyStatement.addActions('codecommit:GitPull');
        pullFromGitPolicyStatement.addResources( this._codeRepository.repositoryArn );
  
        skaffoldBuild.addToRolePolicy( pullFromGitPolicyStatement );
      }    
    }
  }
}
